import JSZip from 'jszip';
import { exportToCSV, exportToExcel, exportToJSON, type ExtractionExportData } from './exportData';
import type { PageAnnotation } from '@/hooks/usePageAnnotations';

export interface ZipExportOptions {
  studyName: string;
  extractionData: ExtractionExportData[];
  annotations?: PageAnnotation[];
  format: 'json' | 'csv' | 'excel';
  includeAnnotations: boolean;
}

/**
 * Create a ZIP file containing extraction data and optionally PDF annotations
 */
export const createZipExport = async (options: ZipExportOptions): Promise<Blob> => {
  const { studyName, extractionData, annotations, format, includeAnnotations } = options;
  const zip = new JSZip();
  
  const timestamp = new Date().toISOString().split('T')[0];
  const sanitizedName = studyName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  
  // Add extraction data in the selected format
  const dataFolder = zip.folder('extraction_data');
  if (!dataFolder) throw new Error('Failed to create data folder');
  
  if (format === 'json') {
    const jsonStr = JSON.stringify(extractionData, null, 2);
    dataFolder.file(`${sanitizedName}_extractions_${timestamp}.json`, jsonStr);
  } else if (format === 'csv') {
    const csvContent = generateCSVContent(extractionData);
    dataFolder.file(`${sanitizedName}_extractions_${timestamp}.csv`, csvContent);
  } else if (format === 'excel') {
    // For Excel, we need to generate the file blob
    const excelBlob = await generateExcelBlob(extractionData);
    dataFolder.file(`${sanitizedName}_extractions_${timestamp}.xlsx`, excelBlob);
  }
  
  // Add annotations if requested and available
  if (includeAnnotations && annotations && annotations.length > 0) {
    const annotationsFolder = zip.folder('pdf_annotations');
    if (!annotationsFolder) throw new Error('Failed to create annotations folder');
    
    // Export annotations as JSON
    const annotationExport = {
      version: "1.0",
      exportDate: new Date().toISOString(),
      studyName,
      totalPages: annotations.length,
      annotations: annotations.map(ann => ({
        pageNumber: ann.pageNumber,
        canvasJSON: ann.canvasJSON,
        thumbnail: ann.thumbnail,
        timestamp: ann.timestamp,
      }))
    };
    
    annotationsFolder.file(
      `${sanitizedName}_annotations_${timestamp}.json`,
      JSON.stringify(annotationExport, null, 2)
    );
    
    // Add a README explaining the contents
    const readme = `# Export Package: ${studyName}
    
Export Date: ${new Date().toISOString()}

## Contents

### extraction_data/
Contains the extracted data from the study in ${format.toUpperCase()} format.

### pdf_annotations/
Contains PDF annotations in JSON format. These can be re-imported into the application.

## How to Import Annotations

1. Open the study in the application
2. Click on the "Import Annotations" button in the PDF viewer
3. Select the annotations JSON file from this export
4. The annotations will be restored to the PDF pages

---
Generated by Systematic Review Data Extraction Tool
`;
    
    zip.file('README.txt', readme);
  } else {
    // If no annotations, just add a simple README
    const readme = `# Export: ${studyName}

Export Date: ${new Date().toISOString()}
Format: ${format.toUpperCase()}

This export contains the extracted data from the study.

---
Generated by Systematic Review Data Extraction Tool
`;
    
    zip.file('README.txt', readme);
  }
  
  // Generate the ZIP file
  const zipBlob = await zip.generateAsync({ 
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });
  
  return zipBlob;
};

/**
 * Create a bulk ZIP export for multiple studies
 */
export const createBulkZipExport = async (
  studies: Array<{
    studyName: string;
    extractionData: ExtractionExportData[];
    annotations?: PageAnnotation[];
  }>,
  format: 'json' | 'csv' | 'excel',
  includeAnnotations: boolean
): Promise<Blob> => {
  const zip = new JSZip();
  const timestamp = new Date().toISOString().split('T')[0];
  
  // Create a folder for each study
  for (const study of studies) {
    const sanitizedName = study.studyName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const studyFolder = zip.folder(sanitizedName);
    if (!studyFolder) continue;
    
    // Add extraction data
    if (format === 'json') {
      const jsonStr = JSON.stringify(study.extractionData, null, 2);
      studyFolder.file(`extractions_${timestamp}.json`, jsonStr);
    } else if (format === 'csv') {
      const csvContent = generateCSVContent(study.extractionData);
      studyFolder.file(`extractions_${timestamp}.csv`, csvContent);
    } else if (format === 'excel') {
      const excelBlob = await generateExcelBlob(study.extractionData);
      studyFolder.file(`extractions_${timestamp}.xlsx`, excelBlob);
    }
    
    // Add annotations if requested and available
    if (includeAnnotations && study.annotations && study.annotations.length > 0) {
      const annotationExport = {
        version: "1.0",
        exportDate: new Date().toISOString(),
        studyName: study.studyName,
        totalPages: study.annotations.length,
        annotations: study.annotations.map(ann => ({
          pageNumber: ann.pageNumber,
          canvasJSON: ann.canvasJSON,
          thumbnail: ann.thumbnail,
          timestamp: ann.timestamp,
        }))
      };
      
      studyFolder.file(
        `annotations_${timestamp}.json`,
        JSON.stringify(annotationExport, null, 2)
      );
    }
  }
  
  // Add a master README
  const readme = `# Bulk Export

Export Date: ${new Date().toISOString()}
Total Studies: ${studies.length}
Format: ${format.toUpperCase()}
Includes Annotations: ${includeAnnotations ? 'Yes' : 'No'}

## Contents

Each study has its own folder containing:
- Extraction data in ${format.toUpperCase()} format
${includeAnnotations ? '- PDF annotations (if available)' : ''}

## Study List

${studies.map((s, i) => `${i + 1}. ${s.studyName}`).join('\n')}

---
Generated by Systematic Review Data Extraction Tool
`;
  
  zip.file('README.txt', readme);
  
  // Generate the ZIP file
  const zipBlob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });
  
  return zipBlob;
};

/**
 * Download a blob as a file
 */
export const downloadBlob = (blob: Blob, filename: string) => {
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  window.URL.revokeObjectURL(url);
};

// Helper function to generate CSV content
const generateCSVContent = (data: ExtractionExportData[]): string => {
  if (data.length === 0) return '';
  
  const headers = Object.keys(data[0]);
  const csvRows = [
    headers.join(','),
    ...data.map(row =>
      headers.map(header => {
        const value = row[header as keyof ExtractionExportData];
        if (value === null || value === undefined) return '';
        const stringValue = String(value);
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }
        return stringValue;
      }).join(',')
    )
  ];
  
  return csvRows.join('\n');
};

// Helper function to generate Excel blob
const generateExcelBlob = async (data: ExtractionExportData[]): Promise<Blob> => {
  // We need to use the XLSX library here
  const XLSX = await import('xlsx');
  const workbook = XLSX.utils.book_new();
  const worksheet = XLSX.utils.json_to_sheet(data);
  
  // Auto-size columns
  const colWidths = Object.keys(data[0] || {}).map(key => {
    const maxLength = Math.max(
      key.length,
      ...data.map(row => String(row[key as keyof ExtractionExportData] || '').length)
    );
    return { wch: Math.min(maxLength + 2, 50) };
  });
  worksheet['!cols'] = colWidths;
  
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Extractions');
  
  // Write to buffer
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
};
